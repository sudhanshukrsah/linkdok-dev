/**
 * Vercel Serverless Function — YouTube Transcript Extraction
 * Extracts captions from YouTube's embedded player data — no API key required.
 *
 * Strategy:
 *  1. Parse videoId from any YouTube URL format
 *  2. Fetch https://www.youtube.com/watch?v=VIDEO_ID (server-side → no CORS)
 *  3. Extract ytInitialPlayerResponse JSON embedded in the page script
 *  4. Grab captionTracks[], prefer English, fall back to first available
 *  5. Fetch the caption XML from YouTube's timedtext endpoint
 *  6. Parse XML into clean paragraph text
 *  7. Return { success, transcript, title, videoId, duration, language }
 */
import { rateLimit, getIP, setCorsHeaders, isOriginAllowed } from './_rateLimit.js';

export default async function handler(req, res) {
  const origin = req.headers['origin'];
  setCorsHeaders(res, origin);

  if (req.method === 'OPTIONS') return res.status(204).end();

  if (origin && !isOriginAllowed(origin)) {
    return res.status(403).json({ error: 'Forbidden' });
  }

  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  // Rate limit: 15 requests / 60s per IP
  const ip = getIP(req);
  const rl = rateLimit(ip, { limit: 15, windowMs: 60_000 });
  if (!rl.allowed) {
    res.setHeader('Retry-After', String(rl.retryAfter));
    return res.status(429).json({ error: 'Too many requests', retryAfter: rl.retryAfter, rateLimited: true });
  }

  const { url } = req.body || {};
  if (!url) return res.status(400).json({ success: false, error: 'URL is required' });

  // ── Step 1: Parse videoId ──────────────────────────────────────────────────
  const videoId = extractVideoId(url);
  if (!videoId) {
    return res.status(200).json({ success: false, error: 'Could not parse YouTube video ID from URL' });
  }

  try {
    // ── Step 2: Fetch YouTube watch page ──────────────────────────────────────
    const watchUrl = `https://www.youtube.com/watch?v=${videoId}`;
    const pageRes = await fetch(watchUrl, {
      headers: {
        'Accept-Language': 'en-US,en;q=0.9',
        'User-Agent':
          'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 ' +
          '(KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36',
      },
      signal: AbortSignal.timeout(15000),
    });

    if (!pageRes.ok) {
      throw new Error(`YouTube page returned HTTP ${pageRes.status}`);
    }

    const html = await pageRes.text();

    // ── Step 3: Extract ytInitialPlayerResponse ───────────────────────────────
    const playerResponse = extractPlayerResponse(html);
    if (!playerResponse) {
      return res.status(200).json({
        success: false,
        error: 'Could not find player data in YouTube page. Video may be private or unavailable.',
        videoId,
      });
    }

    // ── Step 4: Get video title and caption tracks ────────────────────────────
    const title = playerResponse?.videoDetails?.title || '';
    const durationSecs = parseInt(playerResponse?.videoDetails?.lengthSeconds || '0', 10);

    const captionTracks =
      playerResponse?.captions
        ?.playerCaptionsTracklistRenderer
        ?.captionTracks ?? [];

    if (!captionTracks.length) {
      return res.status(200).json({
        success: false,
        error: 'This video has no captions/subtitles available.',
        videoId,
        title,
      });
    }

    // Prefer manual English > auto-generated English > first available
    const preferred = pickBestTrack(captionTracks);

    // ── Step 5: Fetch caption XML ─────────────────────────────────────────────
    const captionUrl = preferred.baseUrl;
    const captionRes = await fetch(captionUrl, {
      headers: {
        'Accept-Language': 'en-US,en;q=0.9',
        'User-Agent':
          'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 ' +
          '(KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36',
      },
      signal: AbortSignal.timeout(10000),
    });

    if (!captionRes.ok) {
      throw new Error(`Caption fetch failed with HTTP ${captionRes.status}`);
    }

    const captionXML = await captionRes.text();

    // ── Step 6: Parse XML to clean transcript ─────────────────────────────────
    const transcript = parseTranscriptXML(captionXML);

    if (!transcript || transcript.length < 50) {
      return res.status(200).json({
        success: false,
        error: 'Captions exist but appear to be empty.',
        videoId,
        title,
      });
    }

    return res.status(200).json({
      success: true,
      videoId,
      title,
      transcript,
      transcriptLength: transcript.length,
      durationSecs,
      language: preferred.languageCode || 'en',
      isAutoGenerated: preferred.kind === 'asr',
    });
  } catch (err) {
    console.error('[YouTube API] Error:', err.message);
    return res.status(200).json({
      success: false,
      error: `Transcript extraction failed: ${err.message}`,
      videoId,
    });
  }
}

// ── Helpers ──────────────────────────────────────────────────────────────────

/**
 * Extract videoId from any YouTube URL format:
 *   https://www.youtube.com/watch?v=ID
 *   https://youtu.be/ID
 *   https://youtube.com/shorts/ID
 *   https://m.youtube.com/watch?v=ID
 *   https://www.youtube.com/embed/ID
 */
function extractVideoId(url) {
  try {
    const u = new URL(url);
    const host = u.hostname.replace('www.', '').replace('m.', '');

    if (host === 'youtu.be') return u.pathname.slice(1).split('?')[0];

    if (host === 'youtube.com') {
      if (u.pathname.startsWith('/watch'))  return u.searchParams.get('v');
      if (u.pathname.startsWith('/shorts/')) return u.pathname.split('/shorts/')[1]?.split('?')[0];
      if (u.pathname.startsWith('/embed/'))  return u.pathname.split('/embed/')[1]?.split('?')[0];
      if (u.pathname.startsWith('/live/'))   return u.pathname.split('/live/')[1]?.split('?')[0];
    }
  } catch {}
  return null;
}

/**
 * Extract ytInitialPlayerResponse from the page HTML.
 * YouTube embeds it as:
 *   var ytInitialPlayerResponse = {...};
 */
function extractPlayerResponse(html) {
  try {
    // Try the most common pattern first
    let match = html.match(/ytInitialPlayerResponse\s*=\s*({.+?})\s*;/s);
    if (!match) {
      // Alternative: inside window["ytInitialPlayerResponse"]
      match = html.match(/window\["ytInitialPlayerResponse"\]\s*=\s*({.+?})\s*;/s);
    }
    if (!match) return null;

    // The JSON can be large and nested — find balanced braces
    const start = html.indexOf(match[1]);
    const json = extractBalancedJSON(html, start);
    return json ? JSON.parse(json) : null;
  } catch (e) {
    console.error('[YouTube API] Failed to parse playerResponse:', e.message);
    return null;
  }
}

/**
 * Extract a balanced JSON object starting at `start` index.
 * Handles nested objects and strings properly.
 */
function extractBalancedJSON(str, start) {
  let depth = 0;
  let inStr = false;
  let escape = false;

  for (let i = start; i < str.length; i++) {
    const ch = str[i];

    if (escape) { escape = false; continue; }
    if (ch === '\\' && inStr) { escape = true; continue; }
    if (ch === '"') { inStr = !inStr; continue; }
    if (inStr) continue;

    if (ch === '{') { depth++; }
    else if (ch === '}') {
      depth--;
      if (depth === 0) return str.slice(start, i + 1);
    }
  }
  return null;
}

/**
 * Pick the best caption track:
 *   Priority: manual English > manual any > auto English > auto any
 */
function pickBestTrack(tracks) {
  const isEn = t => (t.languageCode || '').toLowerCase().startsWith('en');
  const isAuto = t => t.kind === 'asr'; // asr = automatic speech recognition

  return (
    tracks.find(t => !isAuto(t) && isEn(t)) ||   // manual English
    tracks.find(t => !isAuto(t))              ||   // manual any language
    tracks.find(t =>  isAuto(t) && isEn(t))  ||   // auto-generated English
    tracks[0]                                       // whatever is available
  );
}

/**
 * Parse YouTube caption XML into clean readable text.
 *
 * Format: <text start="0.5" dur="4.5">Hello &amp; welcome</text>
 * Also handles <text ...><run>...</run></text> (newer format)
 */
function parseTranscriptXML(xml) {
  const entries = [];
  const regex = /<text[^>]*start="([\d.]+)"[^>]*>([\s\S]*?)<\/text>/g;
  let match;

  while ((match = regex.exec(xml)) !== null) {
    const raw = match[2];
    const text = raw
      .replace(/<[^>]*>/g, '')           // strip inner tags
      .replace(/&amp;/g,  '&')
      .replace(/&lt;/g,   '<')
      .replace(/&gt;/g,   '>')
      .replace(/&quot;/g, '"')
      .replace(/&#39;/g,  "'")
      .replace(/&apos;/g, "'")
      .replace(/&#x(\w+);/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)))
      .replace(/&#(\d+);/g,  (_, dec) => String.fromCharCode(parseInt(dec, 10)))
      .replace(/\n/g,     ' ')
      .replace(/\s+/g,    ' ')
      .trim();

    if (text) entries.push(text);
  }

  // Join entries into paragraphs (~every 10 entries = one paragraph)
  const paragraphs = [];
  for (let i = 0; i < entries.length; i += 10) {
    const chunk = entries.slice(i, i + 10).join(' ');
    paragraphs.push(chunk);
  }

  return paragraphs.join('\n\n');
}
